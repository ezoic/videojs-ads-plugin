'use strict';

/**
 * Inner helper class that deals with the logic of the individual steps needed to setup an ad in the player.
 *
 * @param player {object} instance of the player that will play the ad. It assumes that the videojs-contrib-ads plugin
 *                        has been initialized when you use its utility functions.
 *
 * @constructor
 */

var VASTResponse = require('./VASTResponse');
var VASTError = require('./VASTError');
var VASTTracker = require('./VASTTracker');
var vastUtil = require('./vastUtil');

var async = require('../../utils/async');
var dom = require('../../utils/dom');
var playerUtils = require('../../utils/playerUtils');
var utilities = require('../../utils/utilityFunctions');

var logger = require('../../utils/consoleLogger');

function VASTIntegrator (player) {
  if (!(this instanceof VASTIntegrator)) {
    return new VASTIntegrator(player);
  }

  this.player = player;
  this.enableFullscreenClickIFrame = false;
}

VASTIntegrator.prototype.playAd = function playAd (vastResponse, callback) {
  var that = this;
  callback = callback || utilities.noop;

  console.log(vastResponse);
  // if (!(vastResponse instanceof VASTResponse)) {
  //   return callback(new VASTError('On VASTIntegrator, missing required VASTResponse'));
  // }

  async.waterfall([
    function (next) {
      next(null, vastResponse);
    },
    this._selectAdSource.bind(this),
    this._createVASTTracker.bind(this),
    this._addClickThrough.bind(this),
    this._addClickThroughDivBlocker.bind(this),
    this._addSkipButton.bind(this),
    this._setupEvents.bind(this),
    this._playSelectedAd.bind(this)
  ], function (error, response) {
    if (error && response) {
        if (window.MoatApiReference) {
        	window.MoatApiReference.dispatchEvent({type: 'AdError', adVolume: that.player.volume()});
        }
      that._trackError(error, response);
    }
    callback(error, response);
  });

  this._adUnit = {
    _src: null,
    type: 'VAST',
    pauseAd: function () {
      that.player.pause(true);
    },

    resumeAd: function () {
      that.player.play(true);
    },

    isPaused: function () {
      return that.player.paused(true);
    },

    getSrc: function () {
      return this._src;
    }
  };

  return this._adUnit;
};

VASTIntegrator.prototype._selectAdSource = function selectAdSource (response, callback) {
  var source;

  var ads = response.ads;
  if (!ads || ads.length === 0) {
    return callback(new VASTError('No ads found on the VAST response'));
  }
  var creativeToPlay;
  for (var i = 0, len = ads.length; i < len; i++) {
    if (!ads[i].creatives || ads[i].creatives.length === 0) {
      continue;
    }
    for (var j = 0, lenJ = ads[i].creatives.length; j < lenJ; j++) {
      if (ads[i].creatives[j].mediaFiles && ads[i].creatives[j].mediaFiles.length > 0) {
        creativeToPlay = ads[i].creatives[j];
        break;
      }
    }
    if (creativeToPlay) {
      break;
    }
  }

  var playerWidth = dom.getDimension(this.player.el()).width;
  creativeToPlay.mediaFiles.sort(function compareTo (a, b) {
    var deltaA = Math.abs(playerWidth - a.width);
    var deltaB = Math.abs(playerWidth - b.width);
    return deltaA - deltaB;
  });

  var sources = creativeToPlay.mediaFiles.map(function (mediaFile) {
    mediaFile.src = mediaFile.fileURL;
    return mediaFile;
  });

  source = this.player.selectSource(sources);
  if (source) {
    this.player.trigger({type: 'trace.message', data: {message: 'Playing ' + source.src + ' (type = ' + source.deliveryType + ')'}});
  }

  if (source) {
    logger.info('selected source: ', source);
    if (this._adUnit) {
      this._adUnit._src = source;
    }
    return callback(null, source, response);
  }

  // code 403 <== Couldn't find MediaFile that is supported by this video player
  callback(new VASTError('Could not find Ad mediafile supported by this player', 403), response);
};

VASTIntegrator.prototype._createVASTTracker = function createVASTTracker (adMediaFile, response, callback) {
  try {
    callback(null, adMediaFile, new VASTTracker(adMediaFile.fileURL, response), response);
  } catch (e) {
    callback(e, response);
  }
};

VASTIntegrator.prototype._setupEvents = function setupEvents (adMediaFile, tracker, response, callback) {
  var previouslyMuted;
  var player = this.player;
  player.on('fullscreenchange', trackFullscreenChange);
  player.on('vast.adStart', trackImpressions);
  player.on('pause', trackPause);
  player.on('timeupdate', trackProgress);
  player.on('volumechange', trackVolumeChange);

  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], unbindEvents);
  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel', 'vast.adSkip'], function (evt) {
    if (evt.type === 'vast.adEnd') {
      tracker.trackComplete();
    }
    if (window.MoatApiReference) {
    	var type = evt.type === 'vast.adEnd' ? 'AdVideoComplete' : 'AdStopped';
  	  window.MoatApiReference.dispatchEvent({type: type, adVolume: player.volume()});
    }
  });

  player.one('adStop', function () {
	 player.trigger('vast.adsCancel');
  });

  return callback(null, adMediaFile, response);

  // **** Local Functions **** //
  function unbindEvents () {
    player.off('fullscreenchange', trackFullscreenChange);
    player.off('vast.adStart', trackImpressions);
    player.off('pause', trackPause);
    player.off('timeupdate', trackProgress);
    player.off('volumechange', trackVolumeChange);
  }

  function trackFullscreenChange () {
    if (player.isFullscreen()) {
      tracker.trackFullscreen();
    } else {
      tracker.trackExitFullscreen();
    }
  }

  function trackPause () {
    // NOTE: Whenever a video ends the video Element triggers a 'pause' event before the 'ended' event.
    //       We should not track this pause event because it makes the VAST tracking confusing again we use a
    //       Threshold of 2 seconds to prevent false positives on IOS.
		if (window._molSettings.breakDuration) {
			if (window._molSettings.realVideoDuration) {
			    if (Math.abs(window._molSettings.realVideoDuration - player.currentTime()) < 2) {
			        return;
			    }
			}
		}
		else if (Math.abs(player.duration() - player.currentTime()) < 2) {
	      return;
	    }

    if (window.MoatApiReference) {
    	  window.MoatApiReference.dispatchEvent({type: 'AdPaused', adVolume: player.volume()});
    }
    tracker.trackPause();
    playerUtils.showBigPlayButton(player, true);
    playerUtils.once(player, ['play', 'vast.adEnd', 'vast.adsCancel'], function (evt) {
      if (evt.type === 'play') {
	    if (window.MoatApiReference) {
	    	  window.MoatApiReference.dispatchEvent({type: 'AdPlaying', adVolume: player.volume()});
	    }
        tracker.trackResume();
        playerUtils.showBigPlayButton(player, false);
      }
    });
  }

  function trackProgress () {
    var currentTimeInMs = player.currentTime() * 1000;
    tracker.trackProgress(currentTimeInMs);
  }

  function trackImpressions () {
    if (window.MoatApiReference) {
    	  window.MoatApiReference.dispatchEvent({type: 'AdImpression', adVolume: player.volume()});
    }
    tracker.trackImpressions();
    tracker.trackCreativeView();
  }

  function trackVolumeChange () {
    if (window.MoatApiReference) {
  	  window.MoatApiReference.dispatchEvent({type: 'AdVolumeChange', adVolume: player.volume()});
    }
    var muted = player.muted();
    if (muted) {
      tracker.trackMute();
    } else if (previouslyMuted) {
      tracker.trackUnmute();
    }
    previouslyMuted = muted;
  }
};

VASTIntegrator.prototype._addSkipButton = function addSkipButton (source, tracker, response, callback) {
  var skipOffsetInSec;
  var that = this;

  if (utilities.isNumber(response.skipoffset)) {
    skipOffsetInSec = response.skipoffset / 1000;
    addSkipButtonToPlayer(this.player, skipOffsetInSec);
  }
  callback(null, source, tracker, response);

  // **** Local function **** //
  function addSkipButtonToPlayer (player, skipOffset) {
    var skipButton = createSkipButton(player);
    var updateSkipButton = updateSkipButtonState.bind(that, skipButton, skipOffset, player);

    player.el().appendChild(skipButton);
    player.on('timeupdate', updateSkipButton);

    playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeSkipButton);

    function removeSkipButton () {
      player.off('timeupdate', updateSkipButton);
      dom.remove(skipButton);
    }
  }

  function createSkipButton (player) {
    var skipButton = window.document.createElement('div');
    dom.addClass(skipButton, 'vast-skip-button');
    skipButton.id = 'adSkipButton';

    skipButton.onclick = function (e) {
      if (dom.hasClass(skipButton, 'enabled')) {
          if (window.MoatApiReference) {
        	  window.MoatApiReference.dispatchEvent({type: 'AdSkipped', adVolume: player.volume()});
          }
        tracker.trackSkip();
        player.trigger('vast.adSkip');
      }
      playerUtils.showBigPlayButton(player, false);

      // We prevent event propagation to avoid problems with the clickThrough and so on
      if (window.Event.prototype.stopPropagation !== undefined) {
        e.stopPropagation();
      } else {
        return false;
      }
    };

    return skipButton;
  }

  function updateSkipButtonState (skipButton, skipOffset, player) {
    var timeLeft = Math.ceil(skipOffset - player.currentTime());
    // if skip button enabled never show before-button skip text
    if (timeLeft > 0 && !dom.hasClass(skipButton, 'enabled')) {
        skipButton.innerHTML = '<p class="vast-skip-button-text">' + window._molSettings.skipText.replace('%%TIME%%', utilities.toFixedDigits(timeLeft, 2)) + '</p>';
    } else {
      if (!dom.hasClass(skipButton, 'enabled')) {
        dom.addClass(skipButton, 'enabled');
        skipButton.innerHTML = window._molSettings.skipButtonText;
      }
    }
    var iframeBackButton = window.document.getElementById('iframeBackButton');
    if (!iframeBackButton) {
        skipButton.style.display = 'block';
    }
  }
};

VASTIntegrator.prototype._addClickThrough = function addClickThrough (mediaFile, tracker, response, callback) {
  var enableFullscreenClickIFrame = this.enableFullscreenClickIFrame;

  var player = this.player;
  var blocker = createClickThroughBlocker(player, tracker, response);
  var updateBlocker = updateBlockerURL.bind(this, blocker, response, player);

  player.el().insertBefore(blocker, player.controlBar.el());
  player.on('timeupdate', updateBlocker);
  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeBlocker);

  if (enableFullscreenClickIFrame) {
	  player.on('fullscreenchange', updateDisplayStyle);
  }

  return callback(null, mediaFile, tracker, response);

  // **** Local Functions **** //

  function createClickThroughBlocker (player, tracker, response) {
		if (window._molSettings.disableClickThru) {
		    var blockerDiv = window.document.createElement('div');
		    dom.addClass(blockerDiv, 'vast-blocker');
			return blockerDiv;
		}
    var blocker = window.document.createElement('a');
    var clickThroughMacro = response.clickThrough;

    dom.addClass(blocker, 'vast-blocker');
    // 'a' tag in iOS sometime does not navigate. We will use window.open to navigate for iOS.
    if (!utilities.isIDevice()) {
      blocker.href = generateClickThroughURL(clickThroughMacro, player);
    }

    if (utilities.isString(clickThroughMacro)) {
      blocker.target = '_blank';
    }

    var clickHandler = function (e) {
        if (player.paused()) {
            player.play();

            // We prevent event propagation to avoid problems with the player's normal pause mechanism
            if (window.Event.prototype.stopPropagation !== undefined) {
              e.stopPropagation();
            }
            return false;
        }

        player.pause();
        tracker.trackClick();

        if (window.MoatApiReference) {
          window.MoatApiReference.dispatchEvent({type: 'AdClickThru', adVolume: player.volume()});
        }
        if (utilities.isIDevice()) {
          // We are using window.open to navigate for iOS.
          setTimeout(function () {
            window.open(generateClickThroughURL(clickThroughMacro, player), '_blank');
          }, 1);
          if (window.Event.prototype.stopPropagation !== undefined) {
              e.stopPropagation();
          }
          // player.pause() in iOS sometime does not work. To make sure player paused we will try pause player in 500 msecs.
          setTimeout(function () {
            if (!player.paused()) {
              player.pause();
            }
          }, 500);
        }
        // Brightcove has a bug where they send an "ended" event if paused within a couple seconds of the video end. In this case, the listener
        // that shows the big play button (among other things) gets removed before the handler fires. This fix makes sure the big button still appears.
        var remaining = player.duration() - player.currentTime();
        if (remaining < 3 && remaining > 0) {
          setTimeout(function () {
            playerUtils.showBigPlayButton(player, true);
            playerUtils.once(player, ['playing', 'vast.adEnd', 'vast.adsCancel', 'vast.adSkip'], function () {
              playerUtils.showBigPlayButton(player, false);
            });
          }, 500);
        }
    };

    if (utilities.isIDevice()) {
      blocker.ontouchend = clickHandler;
    }
    else {
      blocker.onclick = clickHandler;
    }

    if (player.isFullscreen() && enableFullscreenClickIFrame) {
    	blocker.style.display = 'none';
    }

    return blocker;
  }

  function updateBlockerURL (blocker, response, player) {
    // 'a' tag in iOS sometime does not navigate. We will use window.open to navigate for iOS.
    if (!utilities.isIDevice()) {
      blocker.href = generateClickThroughURL(response.clickThrough, player);
    }
  }

  function generateClickThroughURL (clickThroughMacro, player) {
    var variables = {
      ASSETURI: mediaFile.src,
      CONTENTPLAYHEAD: vastUtil.formatProgress(player.currentTime() * 1000)
    };

    return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : '#';
  }

  function updateDisplayStyle () {
	  blocker.style.display = player.isFullscreen() ? 'none' : 'block';
  }

  function removeBlocker () {
    player.off('timeupdate', updateBlocker);
	player.off('fullscreenchange', updateDisplayStyle);
    dom.remove(blocker);
  }
};

VASTIntegrator.prototype._addClickThroughDivBlocker = function addClickThrough (mediaFile, tracker, response, callback) {
	if (!this.enableFullscreenClickIFrame) {
		return callback(null, mediaFile, tracker, response);
	}
	var player = this.player;
	  var blocker = createClickThroughDiv(player, tracker, response);
	  var updateBlocker = updateBlockerURL.bind(this, blocker, response, player);
	  var blockerUrl;
	  var iFrame;
	  var iFrameBackButton;

	  player.el().insertBefore(blocker, player.controlBar.el());
	  player.on('timeupdate', updateBlocker);
	  playerUtils.once(player, ['vast.adEnd', 'vast.adsCancel'], removeBlocker);

	  player.on('fullscreenchange', updateDisplayStyle);

	  return callback(null, mediaFile, tracker, response);

	  function createClickThroughDiv (player, tracker) {
	    var blocker = window.document.createElement('div');

	    dom.addClass(blocker, 'vast-blocker');

		if (!window._molSettings.disableClickThru) {
		    blocker.onclick = function (e) {
		      if (player.paused()) {
		        player.play();

		        // We prevent event propagation to avoid problems with the player's normal pause mechanism
		        if (window.Event.prototype.stopPropagation !== undefined) {
		          e.stopPropagation();
		        }
		        return false;
		      }

		      player.pause();
		      tracker.trackClick();

		      if (window.MoatApiReference) {
		    	  window.MoatApiReference.dispatchEvent({type: 'AdClickThru', adVolume: player.volume()});
		      }

		      // create IFrame with back button
		      iFrame = window.document.createElement('iframe');
			  dom.addClass(iFrame, 'vast-blocker');
			  iFrame.src = blockerUrl;
			  blocker.appendChild(iFrame);

			  iFrameBackButton = window.document.createElement('div');
			  dom.addClass(iFrameBackButton, 'vast-back-button');
		      dom.addClass(iFrameBackButton, 'enabled');
			  iFrameBackButton.innerHTML = 'Back';
			  iFrameBackButton.id = 'iframeBackButton';
			  blocker.appendChild(iFrameBackButton);
			  iFrameBackButton.addEventListener('click', function () {
				  blocker.removeChild(iFrame);
				  iFrame = null;
				  blocker.removeChild(iFrameBackButton);
				  iFrameBackButton = null;

				  // show controls
				  var skipButton = window.document.getElementById('adSkipButton');
				  if (skipButton) {
					  skipButton.style.display = 'block';
				  }
				  player.controls(true);

				  if (window.Event.prototype.stopPropagation !== undefined) {
			          e.stopPropagation();
				  }
			  });

			  // hide controls
			  setTimeout(function () {
				  playerUtils.showBigPlayButton(player, false);
			  }, 1);
			  var skipButton = window.document.getElementById('adSkipButton');
			  if (skipButton) {
				  skipButton.style.display = 'none';
			  }
			  player.controls(false);

		    };
		}

	    if (!player.isFullscreen()) {
	    	blocker.style.display = 'none';
	    }

	    return blocker;
	  }

	  function updateBlockerURL (blocker, response, player) {
		  blockerUrl = generateClickThroughURL(response.clickThrough, player);
	  }

	  function generateClickThroughURL (clickThroughMacro, player) {
	    var variables = {
	      ASSETURI: mediaFile.src,
	      CONTENTPLAYHEAD: vastUtil.formatProgress(player.currentTime() * 1000)
	    };

	    return clickThroughMacro ? vastUtil.parseURLMacro(clickThroughMacro, variables) : '#';
	  }

	  function updateDisplayStyle () {
		  blocker.style.display = player.isFullscreen() ? 'block' : 'none';
		  if (!player.isFullscreen() && iFrame) {
			  blocker.removeChild(iFrame);
			  iFrame = null;
			  blocker.removeChild(iFrameBackButton);
			  iFrameBackButton = null;

			  playerUtils.showBigPlayButton(player, true);
			  var skipButton = window.document.getElementById('adSkipButton');
			  if (skipButton) {
				  skipButton.style.display = 'none';
			  }
			  player.controls(true);
		  }
	  }

	  function removeBlocker () {
	    player.off('timeupdate', updateBlocker);
		player.off('fullscreenchange', updateDisplayStyle);
	    dom.remove(blocker);
	  }
};

VASTIntegrator.prototype._playSelectedAd = function playSelectedAd (source, response, callback) {
  var player = this.player;

  // This check is necessary to prevent a race condition where the ad loading waterfall may reach this point after ads were cancelled (mid-waterfall).
  if (player && player.vast && player.vast.adsCancelled === true) {
    callback(null);
    return;
  }

  // window.MoatApiReference = null;

  var mainDuration = player.duration();
  logger.debug('<VASTIntegrator._playSelectedAd>  Main content duration: ' + mainDuration);
  player.preload('auto'); // without preload=auto the durationchange event is never fired
  player.src(source);

  logger.debug('<VASTIntegrator._playSelectedAd> waiting for durationchange to play the ad...');

  playerUtils.once(player, ['durationchange', 'simulateDurationchange', 'error', 'vast.adsCancel'], function (evt) {
    if (tempInt) {
      clearInterval(tempInt);
      tempInt = null;
    }
    if (evt.type === 'durationchange' || evt.type === 'simulateDurationchange') {
      logger.debug('<VASTIntegrator._playSelectedAd> got durationchange; calling playAd()');
      playAd();
    } else if (evt.type === 'error') {
      callback(new VASTError('on VASTIntegrator, Player is unable to play the Ad', 400), response);
    }
    // NOTE: If the ads get canceled we do nothing/
  });

  // !!! Sometimes durationchange event nor fired when source of player changed.
  // In this case we try to figured out if duration changed and fire durationchange event by ourself.
  var durationchangeNotFired = false;
  var tempInt = setInterval(function () {
    logger.debug('<VASTIntegrator._playSelectedAd> Ad video duration: ' + player.duration());
    var curDur = player.duration();
    if (!isNaN(curDur) &&  mainDuration != player.duration()) {
      clearInterval(tempInt);
      tempInt = null;
      durationchangeNotFired = true;
      logger.debug('<VASTIntegrator._playSelectedAd> Trigger simulateDurationchange event');
      player.trigger('simulateDurationchange'); // fire simulateDurationchange event
    }
  }, 500);
  // stop checking duration in 5 secons
  setTimeout(function () {
    if (tempInt) {
      clearInterval(tempInt);
      tempInt = null;
    }
  }, 5000);

  // ***** Local Functions **** //
  function playAd () {

    playerUtils.once(player, ['playing', 'alreadyPlaying', 'vast.adsCancel'], function (evt) {
      if (evt.type === 'vast.adsCancel') {
        return;
      }

      /* Copyright (c) 2011-2016 Moat Inc. All Rights Reserved. */
      /*
      function initMoatTracking(a,c,d,h,k){var f=document.createElement("script"),b=[];c={adData:{ids:c,duration:d,url:k},dispatchEvent:function(a){this.sendEvent?(b&&(b.push(a),a=b,b=!1),this.sendEvent(a)):b.push(a)}};d="_moatApi"+Math.floor(1E8*Math.random());var e,g;try{e=a.ownerDocument,g=e.defaultView||e.parentWindow}catch(l){e=document,g=window}g[d]=c;f.type="text/javascript";a&&a.insertBefore(f,a.childNodes[0]||null);f.src="https://z.moatads.com/"+h+"/moatvideo.js#"+d;return c};
      window.MoatApiReference = null;
      if (response.ads && response.ads.length > 0 && response.ads[0].inLine && response.ads[0].inLine.moat) {
    	  var ids = {level1: response.ads[0].inLine.moat.advid,
    			     level2: response.ads[0].inLine.moat.cpgid,
    			     level3: response.ads[0].inLine.moat.cpid,
    			     level4: response.ads[0].inLine.moat.crid};
    	  if (response.ads[0].inLine.moat.site_id) {
    		  ids.slicer1 = response.ads[0].inLine.moat.site_id;
    	  }
    	  window.MoatApiReference = initMoatTracking(player.el_, ids, player.duration(), response.ads[0].inLine.moat.partnercode, player.currentSource().src);
    	  //window.MoatApiReference = initMoatTracking(player.el_, ids, player.duration(), 'ninemediavpaid78961164', player.currentSource().src);
      }
      if (window._molSettings.viewabilityTracking) {
    	  window._molSettings.viewabilityTracking.init(window._molSettings.viewability.contextId,
    			  player.duration(), player.el_.offsetWidth, player.el_.offsetHeight);
      }
      */

      logger.debug('<VASTIntegrator._playSelectedAd/playAd> got playing event; triggering vast.adStart...');

      player.trigger('vast.adStart');

      if (utilities.isMobile()) {
          // VIDLA-2336 (simulate user activity to make sure control-bar is visible on mobile devices)
          for (var i = 0; i < 5; i++) {
          	setTimeout(function () {
          		player.userActive(true);
          	}, i * 2000);
          }
      }

      if (window.MoatApiReference) {
    	  window.MoatApiReference.dispatchEvent({type: 'AdVideoStart', adVolume: player.volume()});
      }

      player.on('ended', proceed);
      player.on('vast.adsCancel', proceed);
      player.on('vast.adSkip', proceed);

      function proceed (evt) {

          if (evt.type === 'ended') {
              // Ignore ended event if the Ad time was not 'near' the end
              // avoids issues where IOS controls could skip the Ad
            	if (window._molSettings.breakDuration) {
            		if (window._molSettings.realVideoDuration) {
            		    if ((window._molSettings.realVideoDuration - player.currentTime()) > 3) {
            		        return;
            		    }
            		}
            	}
            	else if ((player.duration() - player.currentTime()) > 3) {
    				return;
    			}
            }

        /*
        if(evt.type === 'ended' && (player.duration() - player.currentTime()) > 3 ) {
          // Ignore ended event if the Ad time was not 'near' the end
          // avoids issues where IOS controls could skip the Ad
          return;
        }
        */

        player.off('ended', proceed);
        player.off('vast.adsCancel', proceed);
        player.off('vast.adSkip', proceed);

        // NOTE: if the ads get cancel we do nothing apart removing the listners
        if (evt.type === 'ended' || evt.type === 'vast.adSkip') {
          callback(null, response);
        }
      }
    });

    logger.debug('<VASTIntegrator._playSelectedAd/playAd> calling player.play()...');

    // player.muted(true);
    if (player.currentTime() > 0 || durationchangeNotFired) {
      logger.debug('<VASTIntegrator._playSelectedAd/playAd> Trigger alreadyPlaying event if ad video already playing or durationchange not fired');
      player.trigger('alreadyPlaying');
    }
    else {
      player.play();
    }
  }
};

VASTIntegrator.prototype._trackError = function trackError (error, response) {
  vastUtil.track(response.errorURLMacros, {ERRORCODE: error.code || 900});
};

module.exports = VASTIntegrator;
